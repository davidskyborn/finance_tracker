# асинхронность! поехали. ниже развернутый текст
'''сегодня интересная тема! асинхронность

важно! асинхронность усиливает и ускоряет операции, связанные с Input/Output
относительно операций вычисления (CPU) она бесполезна!
применяется там где надо ждать внешний ресурс:
- сеть (http/websocket)
- базы данных
- чтение записи файлов
- очереди сообщений
- таймеры
- ввод/вывод

синхронный код: ждет, пока выполнит одну задачу до конца, и потом делает вторую
это тормозит процессы, заебывает юзеров и в целом нагрузку на систему
идея асинхронности: пока выполняется один процесс, может выполняться и соседний
если мы открываем 3 страницы, каждая из которых занимает 3, 2 и 1 сек соответственно
то в синхронном коде мы откроем все 3 через 6 секунд
а в асинхронном процесс займет столько, сколько открывается самая долгая = 3 сек

сам python не знает когда ему себя так вести. надо ему помочь!
мы используем для указания на асинхронность 2 инструмента!

1. async def (...)
так мы говорим: "это не обычная функция. она может уступать управление другим"
она не блокирует выполнение

2. await
метка внутри функции, которая говорит "можешь преключиться покая делаюсь"

а что такое event loop? он же реактор
рабочий процесс из разных задач, идет переключение между ними
loop запускает асинхронные функции, видеть await, переключаться на другие и возвращаться

есть крутые штуки. например:
- time.sleep(3) - блокирует поток на 3 секунды, ничего другого выполнить незя
asyncio.sleep(3) - делает await точку, то есть "я сплю 3 секунды, можешь пока делать другое"

мы напишем 2 версии процесса

Версия А - синхронная
Три функции:
- загрузить страницу А (3 сек)
- страницу Б (2 сек)
- страницу С (1 сек)
запущены по очереди, тотал время 6 сек

Версия Б - асинхронная
3 функции, каждая делает await asyncio.sleep(...)
запуск через asyncio.gather(...) чтобы стартовали одновременно
тотал время - 3 сек

что такое asyncio.gather
gather говорит "запусти все 3 задачи вместе и дождись пока все закончатся"
без gather они бы запускались по очереди, что убивает смысл асинхронности

'''
import time
import asyncio

# берем такой же код как из sync_demo
async def load_page(name: str, delay: int) -> None:
    print("начинаю загрузку страницы", name)
    await asyncio.sleep(delay)
    print('страница', name, 'загружена')
'''
async def main():
    await load_page('A', 5)
    await load_page('B', 6)
    await load_page('C', 7)
прописывая await перед каждой функцией мы вызываем их по очереди, не одновременно
'''
# это - код запуска асинхронности
async def main():
    await asyncio.gather(
        load_page('A', 1),
        load_page('B', 2),
        load_page('C', 3),
    )
# в итоге:
# 3 функции без await - выполняются мгновенно
# 3 функции и каждая с await - выполняются ПО ОЧЕРЕДИ
# 3 функции без await, но с asyncio.gather - асинхронно

start = time.time()
asyncio.run(main())
end = time.time()
print('общее время: ', end - start)

'''
функции последовательно:
await A(...)
await B(...)
await C(...)

функции параллельно:
await asyncio.gather(
A(), B(), C()
)

'''