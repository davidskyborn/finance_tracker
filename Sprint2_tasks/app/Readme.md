# Finance Tracker (FastAPI)

Учебный проект для работы с кошельками и балансами на FastAPI.

Проект демонстрирует:
- структуру API на FastAPI;
- использование Pydantic-схем;
- документирование эндпоинтов через docstring и параметры FastAPI;
- статическую типизацию (mypy);
- автоформатирование кода (black, isort);
- управление зависимостями через Poetry.

---

## Требования

- Python 3.12
- Poetry (установлен глобально)
- git (опционально, если проект клонируется из репозитория)

---

## Установка зависимостей

1. Перейти в корень проекта (там, где лежит `pyproject.toml`):

   ```bash
   cd /путь/к/папке/finance_tracker

2. Установить зависимости через Poetry:


    poetry install

## Запуск приложения

1. Активировать виртуальное окружение Poetry (опционально):
    

    poetry shell


2. Запустить сервер разработки uvicorn:


    poetry run uvicorn app.main:app --reload

3. Открыть документацию Swagger в браузере:


Swagger UI: http://127.0.0.1:8000/docs


Альтернативная документация ReDoc: http://127.0.0.1:8000/redoc


## Статическая типизация (mypy)
Для проверки типизации используется mypy с настройками в pyproject.toml.
Запуск проверки: 

    poetry run mypy app

Ожидаемый результат для корректного решения:

    Success: no issues found in N source files

    
## Форматирование кода (black и isort)
Форматирование кода настроено через pyproject.toml:
- black — единый стиль форматирования Python-кода;
- isort — сортировка импортов по группам и алфавиту.

Запуск isort:

    poetry run isort app

Запуск black:

    poetry run black app

После выполнения этих команд код будет приведён к единому стилю, который ожидается в задании.

## Документация и типы
В проекте используются:

- docstring у всех функций и эндпоинтов в стиле PEP 257 (краткое описание, затем Args/Returns/Raises);
- параметры summary, description, response_description в декораторах FastAPI для корректной документации в Swagger;
- типовые аннотации (включая Optional, list[...], собственные Pydantic-модели) и проверка через mypy.

Это обеспечивает читаемость кода и более предсказуемое поведение на этапе разработки.